


# promise

```js
let promise = new Promise(function(resolve, reject) {
    // executor
})
```

```js
let promise = new Promise(function(resolve, reject) {
    resolve("done");
    reject(new Error("..."));
    setTimeout(() => resolve("..."));
});

promise;
/*
Promise {<resolved>: "done"}
    __proto__: Promise
        catch: ƒ catch()
        constructor: ƒ Promise()
            all: ƒ all()
            allSettled: ƒ allSettled()
            arguments: (...)
            caller: (...)
            length: 1
            name: "Promise"
            prototype: Promise {Symbol(Symbol.toStringTag): "Promise", constructor: ƒ, then: ƒ, catch: ƒ, finally: ƒ}
                catch: ƒ catch()
                constructor: ƒ Promise()
                finally: ƒ finally()
                then: ƒ then()
                Symbol(Symbol.toStringTag): "Promise"
                __proto__: Object
            race: ƒ race()
            reject: ƒ reject()
            resolve: ƒ resolve()
            Symbol(Symbol.species): (...)
            get Symbol(Symbol.species): ƒ [Symbol.species]()
            __proto__: ƒ ()
            [[Scopes]]: Scopes[0]
        finally: ƒ finally()
        then: ƒ then()
        Symbol(Symbol.toStringTag): "Promise"
        __proto__: Object
    [[PromiseStatus]]: "resolved"
    [[PromiseValue]]: "done"
*/

promise.__proto__ === Promise.prototype; // true
Promise.prototype.constructor.prototype === Promise.prototype; // true
```

executor 获得结果后调用回调

- 执行成功调用 resolve(value)
- 执行失败调用 reject(error)

promise对象

![image](https://cdn.nlark.com/yuque/0/2020/png/419446/1590160843470-dec89e75-90f3-4075-9cd2-e6e71d9b8524.png)


对比初始状态下的promise
```js
let promise = new Promise(function(resolve, reject) {});
promise;
/*
Promise {<pending>}
    __proto__: Promise
    [[PromiseStatus]]: "pending"
    [[PromiseValue]]: undefined
*/
```

成功返回
```js
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done"), 1000);
});

promise;
/*
Promise {<resolved>: "done"}
    __proto__: Promise
    [[PromiseStatus]]: "resolved"
    [[PromiseValue]]: "done"
*/
```

错误处理
```js
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// Uncaught (in promise) Error: Whoops!

promise;
/*
Promise{<rejected>: Error: Whoops!
    at <anonymous>:2:29}
    __proto__: Promise
    [[PromiseStatus]]: "rejected"
    [[PromiseValue]]: Error: Whoops!
    at <anonymous>:2:29
*/
```

executor只能调用一个结果，成功或错误



## 消费者 then, catch, finally

### then

接收两个参数，两个参数都是函数。第一个函数在resolved后运行并接收结果，第二个函数在rejected后运行并接收error

```js
promise.then(
    function(result) {},
    function(error) {}
    );
```

```js
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done!"), 1000);
});

promise.then(
    result => alert(result),
    error => alert(error)
);
```

### catch

error

```js
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error("Wooops")), 1000);
});

promise.catch(alert); // promise.then(null, f)
```

### finally

将结果和error传递给下一个程序
```js
new Promise((resolve, reject) => {
    setTimeout(() => resolve("result"), 2000)
})
.finally(() => alert("Promise ready"))
.then(result => alert(result));
```
error
```js
new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Promise ready"))
  .catch(err => alert(err)); 
  
  
new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("error")), 2000)
})
.finally(() => alert("Promise ready"))
.catch(alert);
```











